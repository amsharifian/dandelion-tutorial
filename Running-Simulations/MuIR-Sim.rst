.. _muirsim:

muIR Simulator
==========================

In this page, I briefly explain how to simulate a software defined accelerator, using Dandelion framework.


muIR Generator
-------------------

muIR Generator is a compiler that reads an input program and generate an accelerator using `muIR-lib Chisel Library <https://github.com/sfu-arch/muir-lib>`_.

Let's look at an example that how to muIR work:

To build muIR please follow the readme section in the following `readme page <https://github.com/sfu-arch/muir>`_.
After building muIR, we get accelerator files for the example C files:

.. code-block:: bash

    cd build
    source scripts/setup-env.sh
    cd tests/c
    make

The output of this command is a set off scala files that is the accelerator definition for each function in scala, let's look at `test01`:

The C code for this test is:

.. code-block:: C

    unsigned test01(unsigned a, unsigned b){
        return  a * b;
    }

    int main(){
        unsigned a = 5;
        unsigned b = 3;
        unsigned prod;

        prod = test01(a,b);
        printf("prod=%u\n", prod);
        return 0;
    }


The target function is `test01` and the generated accelerator file is `test01.scala`.
The important part for test01.scala file is the class signature:

.. code-block::scala

    class test01DF(ArgsIn: Seq[Int] = List(32, 32), Returns: Seq[Int] = List(32))
    			(implicit p: Parameters) extends DandelionAccelModule(ArgsIn, Returns){


What the signature tells us is that the input arguments to test01 is two values that each of them are 32bit: ``ArgsIn: Seq[Int] = List(32, 32)``.
And test01 accelerator returns one 32bits value: ``Returns: Seq[Int] = List(32)``.

But this scala file is only the definition of test01 function in scala and this file needs to be connected to overall accelerator Shell.
The first step, is to clone ``muir-sim`` project and copy the generated scala file in the following path

.. code-block:: bash

    cp test01.scala mir-sim/hardware/chisel/src/main/scala/generator


Next step is to connect the Dataflow to the accelerator shell.

The accelerator `shell` is defined in `muir-sim <https://github.com/sfu-arch/muir-sim>`_. At this moment, we support the following shells:

* **SimShell**    -- It uses Verilator and DPI memory module to simulate the accelerator behaviour
* **XilinxShell** -- We use the XilinxShell to use Xilinx SoC boards
* **IntelShell**  -- We use the IntelShell to use Intel SoC boards
* **F1Shell**     -- We use the F1Shell to use AWS F1 instances


The following figure shows the overall design of our Shells:


.. thumbnail:: ./figures/DCR.png
    :align: center

    Figure legends

.. centered::  **Figure 1: Dandelion Shell**

In ``muir-sim`` repo, you can find the shell definition in the following path: 
``muir-sim/hardware/chisel/src/main/scala/shell/``.

Each of these shells are instantiated in the following path with the proper configuration for AXI and accelerator interface:

``muir-sim/hardware/chisel/test/main/scala/accel/VCRAccel.scala``

Currently, there is one class in this file the first class is ``DandelionSimAccel`` which is for simulation:

.. code-block::scala
    
    class DandelionSimAccel[T <: DandelionAccelModule](accelModule: () => T)
                                                      (numPtrs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                                                      (implicit val p: Parameters) extends MultiIOModule with HasAccelShellParams {


The input to this class is:

1. The accelerator dataflow which is generated by ``muir-generator``
2. Input parameters that describe the accelerator control register unit, ``DCR``.


In ``VCRAccel.scala`` file there is an main object that instantiate ``DandeliomSimAccel`` class and allows the designer to generate a verilog for the whole accelerator.

.. code-block:: scala

    object DandelionSimAccelMain extends App {

      //These are default values for VCR
      var num_ptrs = 4
      var num_vals = 2
      var num_returns = 1
      var num_events = 1
      var num_ctrl = 1
      args.sliding(2, 2).toList.collect {
        case Array("--num-ptrs", argPtrs: String) => num_ptrs = argPtrs.toInt
        case Array("--num-vals", argVals: String) => num_vals = argVals.toInt
        case Array("--num-rets", argVals: String) => num_returns = argVals.toInt
        case Array("--num-event", argEvent: String) => num_vals = argEvent.toInt
        case Array("--num-ctrl", argCtrl: String) => num_vals = argCtrl.toInt
      }

      /**
       * @note make sure for simulation dataLen is equal to 64
       *       Pass generated accelerator to TestAccel
       */
      implicit val p =
        new WithSimShellConfig(dLen = 64, pLog = true)(nPtrs = num_ptrs, nVals = num_vals, nRets = num_returns, nEvent = num_events, nCtrl =  num_ctrl)
      chisel3.Driver.execute(args.take(4),
        () => new DandelionSimAccel(() => new test01DF())(num_ptrs, num_vals, num_returns, num_events, num_ctrl))
    }

This object file parse the command line input argument to reads the following variables:

* Number of Pointers
* Number of Values
* Number of Event counters 
* Number of Return values

It defines a proper config file that contain proper configuration values for each shell and finally the actual accelerator module.
For instance, in this case in the last line the accelerator that we are passing to the Shell is ``test01DF``.

Finally, if you run the following command, in the simulation case, you will generate both the verilog design and the C++ model of the accelerator:

.. code-block:: bash

    make chisel NPROCS=4 NUM_PTRS=0 NUM_VALS=2 NUM_RETS=1


The verilog file well be generated in the following path: ``muir-sim/hardware/chisel/build/chisel``